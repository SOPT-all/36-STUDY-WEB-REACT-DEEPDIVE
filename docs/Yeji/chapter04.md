# 📚 [ 모던 리액트 딥다이브] - 04장 : 서버 사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

## 4.1.1 싱글 페이지 애플리케이션의 세상

### 싱글 페이지 애플리케이션이란?

싱글 페이지 애플리케이션(SPA: Single Page Application)은 웹 애플리케이션의 한 종류로, 서버로부터 완전한 새로운 페이지를 불러오지 않고 현재의 페이지를 동적으로 다시 작성함.

#### SPA의 주요 특징

1. **클라이언트 사이드 렌더링**

   - 모든 렌더링과 라우팅이 브라우저의 자바스크립트에 의존함
   - 최초 로딩 시 필요한 모든 리소스를 한 번에 다운로드함
   - 이후 페이지 전환은 자바스크립트를 통해 동적으로 처리됨

2. **페이지 전환 방식**

   - `history.pushState`와 `history.replaceState` API를 활용함
   - 새로운 HTML 페이지를 요청하지 않고 필요한 데이터만 HTTP 요청함
   - DOM 조작을 통해서 페이지를 전환함

3. **장점**

   - 빠른 페이지 전환과 부드러운 사용자 경험을 제공함
   - 서버 부하가 감소함 (필요한 데이터만 주고받음)

4. **단점**
   - 초기 로딩 시간이 길어질 수 있음
   - SEO(검색 엔진 최적화)에 불리함
   - 자바스크립트가 비활성화된 환경에서는 작동하지 않음
   - 메모리 관리에 주의가 필요함

#### SPA의 동작 원리

1. **초기 로딩**

   - 서버로부터 최소한의 HTML, CSS, JavaScript 파일을 다운로드함
   - 애플리케이션의 기본 구조와 필요한 모든 리소스를 로드함

2. **라우팅 처리**

   - URL 변경 시 서버에 새로운 페이지를 요청하지 않음
   - 자바스크립트 라우터가 URL 변경을 감지함
   - 필요한 컴포넌트만 동적으로 로드하고 렌더링함

3. **데이터 통신**
   - 필요한 데이터만 JSON 형태로 주고받음
   - 받은 데이터를 기반으로 DOM을 업데이트함

### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교

#### 전통적인 웹 애플리케이션 (MPA: Multi Page Application)

- 페이지 전환 시마다 서버에 새로운 HTML 페이지를 요청함
- 매번 새로운 페이지를 처음부터 다시 다운로드하고 렌더링하는 작업을 거쳐야 함
- 서버에서 완성된 HTML을 받아와서 화면에 표시함
- 페이지 전환 시 깜빡임 현상이 발생할 수 있음
- 서버의 부하가 증가할 수 있음

#### 싱글 페이지 애플리케이션 (SPA)

- 최초에 한 번만 모든 리소스를 다운로드함
- 이후 페이지 전환 시 추가로 리소스를 다운로드할 필요가 없음
- 자바스크립트를 통해 동적으로 페이지를 전환함
- 필요한 데이터만 서버와 주고받으므로 서버 부하가 감소함

### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

과거 PHP나 JSP를 기반으로 한 웹 애플리케이션은 대부분의 렌더링이 서버 사이드에서 이루어졌음. 사용자가 페이지를 요청하면 서버에서 완성된 HTML을 제공하고, 페이지 이동 시에도 새로운 페이지를 서버에서 받아오는 방식이었음.

자바스크립트의 역할이 확대되면서 모듈화에 대한 필요성이 대두되었고, 이에 따라 CommonJS와 AMD와 같은 모듈 시스템이 등장함.

2010년경에는 Backbone.js, AngularJS, Knockout.js 등의 프레임워크가 등장하면서 자바스크립트 기반의 MVx 패턴을 구현하기 시작함. 이 시점부터 자바스크립트의 역할과 규모가 급격히 커지기 시작함.

기존의 LAMP 스택(리눅스, 아파치, MySQL, PHP)은 서버 중심의 아키텍처였음. 과거 자바스크립트의 기능이 제한적이었기 때문에 대부분의 처리를 서버에서 수행했음. 이러한 서버 의존적인 구조는 웹 애플리케이션의 확장성에 큰 걸림돌이 되었음. 기능이 다양해지거나 사용자가 늘어날 때마다 서버를 확장해야 했지만, 클라우드 개념이 부족했던 당시에는 서버 확장이 매우 어려웠음.

JAM 스택은 대부분의 작업을 자바스크립트에서 수행할 수 있게 되면서 프론트엔드는 마크업을 미리 빌드하여 정적으로 사용자에게 제공하고, 이후의 모든 동작은 클라이언트 측에서 실행되기 때문에 서버 확장성 문제에서 자유로워질 수 있었음.

## 4.1.2 서버 사이드 렌더링이란?

서버 사이드 렌더링(SSR)은 웹 페이지의 초기 HTML을 서버에서 생성하여 클라이언트에게 전달하는 방식임. 이는 웹 애플리케이션의 렌더링 책임을 서버에 두는 것으로, 클라이언트 사이드 렌더링과는 다른 접근 방식을 취함. 서버에서 완성된 HTML을 제공하기 때문에 안정적인 렌더링이 가능함.

### 서버 사이드 렌더링의 장점

**최초 페이지 진입이 비교적 빠르다**

- First Contentful Paint(FCP) 시간이 단축됨
  - 사용자가 페이지에 진입했을 때 유의미한 콘텐츠가 화면에 그려지는 시간이 빨라짐
- HTTP 요청에 의존적인 렌더링이나 큰 HTML 크기의 경우 특히 효과적임
- 단, 서버의 성능과 리소스가 부족한 경우 SPA보다 느릴 수 있음

**검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다**

검색 엔진이 사이트에서 필요한 정보를 가져가는 과정은 아래와 같음.

1. 검색 엔진 로봇(머신)이 페이지에 진입함
2. 페이지가 HTML 정보를 제공해 로봇이 HTML을 다운로드 함. (다운로드만 하고 자바스크립트 코드는 실행하지 않음.) 3.다운로드한 HTML 페이지 내부의 오픈 그래프나 메타 태그 정보를 기반으로 페이지의 검색 정보를 가져오고 이를 바탕으로 검색 엔진에 저장함.

- 검색 엔진 로봇은 페이지를 보는 것이 아니라 정적인 정보를 가져오는 것이 목적이기 때문에 콘텐츠를 더 쉽게 크롤링할 수 있음
- SNS 공유 시 메타데이터(제목, 설명, 이미지 등)를 정확하게 제공 가능
- 검색 엔진에게 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있어서 검색 엔진 최적화에 대응하기 용이함.

**누적 레이아웃 이동이 적다**

누적 레이아웃 이동(Cummulative Layout Shift)는 사용자에게 페이지를 보여준 이후에 HTML 정보가 추가되거나 삭제되어 화면이 덜컥거리며 사용자가 예상치 못한 시점에서 페이지가 변경되어 부정적인 사용자 경험을 초래하는 것을 말함. 서버 사이드 렌더링은 요청이 완전히 완료된 이후에 완성된 페이지를 제공하기 때문에 레이아웃 이동이 최소화 될 수 있고, 초기 렌더링 시에 필요한 모든 리소스를 포함하여 전달함.

**사용자의 디바이스 성능에 비교적 자유롭다**

자바스크립트 실행이 사용자 디바이스에서만 이루어지고 디바이스의 성능에 절대적으로 의존적임.
서버 사이드 렌더링은 렌더링 작업을 서버 쪽에 부담을 나눌 수 있기 때문에 클라이언트의 부하가 감소하고 일관된 성능을 제공할 수 있음.

**보안에 좀 더 안전하다**

JAM 스택은 모든 비즈니스 로직이 클라이언트에 노출됨. API 호출과 인증 로직이 브라우저에서 실행되기 때문에 보안 위협 가능성이 있음. 서버 사이드 렌더링은 민감한 로직을 서버에서 처리하기 때문에 인증 및 권한 검증을 서버에서 수행하고 클라이언트에는 필요한 데이터만 전달함. 그래서 보안 위협을 방어할 수 있음.

### 단점

**소스코드를 작성할 때 항상 서버를 고려해야 한다**
서버 사이드 렌더링에서는 코드가 서버와 클라이언트 양쪽에서 실행될 수 있기 때문에, `window`, `document`와 같은 브라우저 전용 API를 사용할 때는 주의가 필요함. 이러한 API들은 서버 환경에서는 사용할 수 없으므로, 코드 실행 환경을 확인하는 조건문을 추가하거나 클라이언트 사이드에서만 실행되도록 처리해야 함.

**적절한 서버가 구축돼 있어야 한다**
사용자 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량을 확보해야 하며, 예기치 못한 상황에 대응할 수 있는 복구 전략도 필요함. 또한 요청을 분산하거나 PM2와 같은 프로세스 매니저의 도움도 필요함.

**서비스 지연에 따른 문제**
서버 사이드 렌더링은 서버에서 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기 전까지는 어떤 정보도 제공할 수 없기 때문에, 병목 현상이 심해진다면 부정적인 사용자 경험을 제공할 수 있음.

## 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

### 서버 사이드 렌더링 역시 만능이 아니다

클라이언트에서 발생하는 무거운 작업을 모두 서버에 넘긴다고 해서 성능이 반드시 개선되는 것은 아님.
설계가 잘못되면 성능 개선 효과는 없고, 오히려 서버와 클라이언트를 모두 관리해야 하는 부담이 생길 수 있음.

웹페이지의 목적과 우선순위에 따라, 싱글 페이지 애플리케이션(SPA)이 더 효율적인 선택이 될 수 있음.

### 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션

SPA는 최초 진입 시 꼭 필요한 정보만 요청하여 렌더링함.중요도가 낮은 리소스는 lazy loading으로 처리하여 렌더링을 방해하지 않도록 함. 코드 분할을 통해 자바스크립트 리소스의 불필요한 다운로드와 실행을 최소화하고, 라우팅이 발생할 경우, 변경된 부분만 교체하여 사용자 피로도를 줄임.

평균적으로 SPA가 SSR보다 초기 로딩 속도는 느린 편임. 라우팅 최적화가 되지 않은 경우, 사용자 기기의 성능에 따라 사용 경험이 달라질 수 있음. 페인트 홀딩, bf cache, shared element transitions 등의 브라우저 기술을 활용하기 어려운 경우도 있지만, 잘 구성된 SPA는 더 나은 사용자 경험을 제공할 수 있음.

### 현대의 서버 사이드 렌더링

최근에는 초기 진입 시 서버가 완성된 HTML을 내려주는 SSR 방식과, 이후에는 클라이언트에서 SPA처럼 동작하는 하이브리드 방식이 일반화되고 있음. 이를 통해 초기 로딩 속도를 확보하면서도, 이후 사용자 인터랙션에서는 SPA의 장점을 함께 가져갈 수 있음.

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

## 4.2.1 `renderToString`

renderToString은 인수로 넘겨받은 리액트 컴포넌트를 렌더링하여 HTML 문자열로 반환하는 함수임.
이 함수의 목적은 클라이언트가 화면을 그리기 전에, 브라우저가 해석 가능한 HTML을 먼저 제공하는 데 있음.

해당 함수는 리액트 컴포넌트를 기준으로 마크업을 생성하지만, 이벤트 핸들러는 결과물에 포함되지 않음.
이는 브라우저에서 동작하는 자바스크립트가 아니고 HTML 마크업만 생성하기 때문임.

또한 renderToString을 통해 생성된 HTML에는 data-reactroot 속성이 포함되며, 나중에 hydrate() 함수가 해당 DOM 요소를 리액트 루트로 인식하기 위한 기준점이 됨.

메타 정보 삽입도 가능하므로, SEO 최적화나 초기 콘텐츠 노출 목적에도 활용할 수 있음.

```tsx
import { renderToString } from "react-dom/server";
import App from "./App";

const html = renderToString(<App />);
```

## 4.2.2 `renderToStaticMarkup`

renderToStaticMarkup은 리액트 컴포넌트를 HTML 문자열로 변환하지만, 리액트에서만 사용하는 특수 속성(data-reactroot 등)은 생성하지 않음.

결과적으로 리액트와 관련된 메타 데이터 없이 순수한 HTML만 반환되므로, 파일 크기를 조금 줄일 수 있음.

이 함수는 hydrate를 수행하지 않는 다는 것을 가정하기 때문에, 브라우저에서 자바스크립트를 실행할 수 없음.
따라서, 이벤트 핸들러나 인터랙션이 필요한 경우에는 사용할 수 없으며, 이벤트 리스너가 불필요한 정적 HTML을 생성할 때만 사용해야 함.

```tsx
import { renderToStaticMarkup } from "react-dom/server";
import App from "./App";

const staticHtml = renderToStaticMarkup(<App />);
```

## 4.2.3 `renderToNodeStream`

renderToNodeStream은 Node.js 환경에 의존하여 동작하기 때문에 브라우저 환경에서는 사용할 수 없음.

이 함수의 반환값은 Node.js의 ReadableStream 타입임.
utf-8로 인코딩된 바이트 스트림을 반환하며, Node.js나 Deno, Bun과 같은 서버 환경에서 사용할 수 있음.
-> 사용자가 원하는 문자열(string) 형태를 얻기 위해서는 별도의 처리가 필요함.

결과로 생성된 ReadableStream 객체 자체는 브라우저에서도 존재하는 타입이지만,
이 스트림을 생성하는 과정이 Node.js 내부 API에 의존하기 때문에 브라우저에서 직접 생성할 수 없음.

renderToString을 사용할 때 HTML 크기가 작다면 굳이 스트림이 필요하지 않음.
하지만 HTML의 크기가 클 경우에 renderToNodeStream을 사용하면 데이터를 청크 단위로 나누어 순차적으로 전송할 수 있기 때문에 초기 렌더링 속도 향상이나 메모리 사용 최적화 등의 이점이 있음.

널리 알려진 서버 사이드 렌더링 프레임워크는 renderToNodeStream을 채택하고 있음.

## 4.2.4 `renderToStaticNodeStream`

동일하게 Node.js의 ReadableStream 타입의 결과물을 반환하고, 자바스크립트에 필요한 리액트 속성이 제공되지 않는다.
그렇기 때문에 hydrate 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드임.

## 4.2.5 `hydrate`

hydrate는 renderToString이나 renderToNodeStream으로 생성된 정적인 HTML 콘텐츠에 자바스크립트 이벤트 핸들러를 연결하는 역할을 함. 서버에서 생성된 HTML을 기반으로 클라이언트에서 인터랙션이 가능한 웹페이지로 만드는 과정임.

비슷한 함수로 render가 있음. render는 컴포넌트와 HTML 요소를 인수로 받아 해당 요소에 컴포넌트를 렌더링하고 이벤트 핸들러까지 한 번에 부착함. <-> hydrate는 이미 렌더링된 HTML을 기준으로 이벤트만 연결하는 점에서 차이가 있음.

```tsx
import * as ReactDOM from "react-dom";
import App from "./App";

// containerId를 가리키는 element는 서버에서 렌더링된 HTML의 특정 위치를 의미함
const element = document.getElementById(containerId);

// 해당 element를 기준으로 리액트 이벤트 핸들러를 붙임
ReactDOM.hydrate(<App />, element);
```

hydrate는 서버에서 전달된 HTML이 클라이언트에서 렌더링되는 결과와 동일하다는 전제 하에 동작함.
따라서 두 번째 인수로 넘기는 HTML 요소는 renderToString 또는 renderToNodeStream으로 생성된 정적 리액트 마크업이어야 함.

만약 renderToStaticMarkup처럼 리액트 관련 메타 정보가 포함되지 않은 HTML을 기준으로 hydrate를 실행하면,
경고 메시지가 출력됨. 이는 리액트가 해당 요소를 리액트 컴포넌트의 루트로 인식할 수 없기 때문임.

또한 hydrate는 내부적으로 서버에서 생성된 HTML과 클라이언트 렌더링 결과가 일치하는지 비교하는 과정을 거침.
이 과정에서 불일치가 발생하면 React는 경고를 출력함. 이런 경우 suppressHydrationWarning 속성을 사용하여 경고를 억제할 수 있음.
하지만 이 속성은 제한적으로만 사용하는 것이 권장됨, 왜냐하면 실제 불일치를 무시할 경우 의도치 않은 렌더링 결과로 이어질 수 있기 때문임.

## 4.3 Next.js 톺아보기

## 4.3.2 Next.js 시작하기

```bash
npx create-next-app@latest --ts
```

- \_app.tsx

  - 애플리케이션 전체 페이지 시작점
  - Next.js를 초기화 하는 파일
  - 에러 바운더리 통해 전역 에러 처리, 전역 CSS 선언, 공통으로 사용되는 데이터 제공 가능

- \_document.tsx

  - html이나 body 태그에 DOM 속성을 추가하고 싶다면 사용
  - 무조건 서버에서 실행되기 때문에 이벤트 핸들러 추가 불가능
  - CSS-in-JS 스타일을 서버에서 모아 HTML로 제공하는 작업 가능

## 4.3.3 Data Fetching

pages/의 폴더에 있는 라우팅이 되는 파일에서만 사용할 수 있고, 예약어로 지정되어 반드시 정해진 함수명으로 export를 사용하여 함수를 외부로 내보내야 한다.

### getStaticPaths / getStaticProps

이 두 함수는 **정적 페이지 생성**에 사용됨.

- getStaticPaths:
  - 동적 라우팅 페이지(pages/post/[id].tsx 등)에서 사용됨.
  - 어떤 경로들을 정적으로 미리 생성할지 정의하는 함수임.
  - 리턴한 paths 배열을 기반으로 각 경로에 대해 getStaticProps가 실행됨.
- getStaticProps:
  - 해당 페이지로 요청이 들어왔을 때 페이지에 전달할 props를 정적으로 생성하는 함수임.
  - 빌드 시 실행되어 결과를 HTML과 함께 정적으로 저장함.

### getServerSideProps

getServerSideProps는 페이지 요청이 들어올 때마다 서버에서 실행되는 함수임.
이 함수가 정의되어 있다면, 사용자가 해당 페이지에 진입하기 전에 무조건 먼저 실행됨.

응답값에 따라서 페이지 루트 컴포넌트에 props를 반환할 수도 있고 다른 페이지로 리다이렉트 시킬 수도 있음.

### getInitialProps

getInitialProps는 페이지 컴포넌트나 \_app.tsx에서 사용 가능한 데이터 패칭 함수임.
클라이언트와 서버 모두에서 실행될 수 있으며, 페이지 렌더링 전에 데이터를 불러오는 용도로 사용함.

하지만 대부분의 경우 getStaticProps나 getServerSideProps를 사용하는 것이 권장됨.

## 4.3.4 스타일 적용하기

### 컴포넌트 레벨 CSS

[name].module.css와 같은 명명규칙을 사용함.

### 4.3.6 next.config.js

```js
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
```

- basePath: 앱의 모든 라우트 앞에 붙는 기본 경로를 설정함

- swcMinfy : SWC 기반의 고속 자바스크립트 압축을 활성화함

- poweredByHeader : 응답 헤더에 x-powered-by: Next.js를 표시할지 여부 설정함

- redirects : 특정 경로를 다른 경로로 리다이렉트할 수 있도록 설정함

- reactStrictMode : 리액트의 StrictMode 설정 여부. true로 설정하는 것이 좋음.

- assetPrefix : next에서 빌드된 결과물을 동일한 호스트가 아니라 다른 CDN 등에 업로드하고자 할 때 사용
